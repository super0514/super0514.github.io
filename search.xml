<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>杭州滴滴测开一面总结</title>
      <link href="/2022/03/17/hang-zhou-di-di-ce-kai-yi-mian-zong-jie/"/>
      <url>/2022/03/17/hang-zhou-di-di-ce-kai-yi-mian-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>滴滴的测开一面，一紧张忘记录音了，乘着刚结束，先把面经写下来。<br>第一次参加面试，太紧张了，第一次在记事本里写代码，当时人有点懵。</p><p>先做了一个自我介绍，不太会做这方面的自我介绍，简单说了下以及介绍了下项目，说话有点结巴，没组织好语言，害。<br>然后正式开始面试。</p><h3 id="1-TCP-x2F-UDP的区别"><a href="#1-TCP-x2F-UDP的区别" class="headerlink" title="1.TCP&#x2F;UDP的区别"></a>1.TCP&#x2F;UDP的区别</h3><p>回答了一下面对连接和无连接，传输方式和应用场景，说的结结巴巴，太紧张了呜呜呜</p><h3 id="2-HTTP-x2F-HTTPS的区别"><a href="#2-HTTP-x2F-HTTPS的区别" class="headerlink" title="2.HTTP&#x2F;HTTPS的区别"></a>2.HTTP&#x2F;HTTPS的区别</h3><p>回答了http的无状态，明文传输，不安全，https的加密ssl&#x2F;stl协议，然后对http和https的传输速度和过程进行了一下对比，后边卡住了呜呜，面试官姐姐很温柔，立马切换了问题。</p><h3 id="3-有了解过接口相关吗？"><a href="#3-有了解过接口相关吗？" class="headerlink" title="3.有了解过接口相关吗？"></a>3.有了解过接口相关吗？</h3><p>直接回答不会，当时没想到接口是啥，很尴尬</p><h3 id="4-接口的连接方式？"><a href="#4-接口的连接方式？" class="headerlink" title="4.接口的连接方式？"></a>4.接口的连接方式？</h3><p>回答了最常见的get、post  看了面经记得还有delete、put等</p><h3 id="5-GET-x2F-POST的区别"><a href="#5-GET-x2F-POST的区别" class="headerlink" title="5.GET&#x2F;POST的区别"></a>5.GET&#x2F;POST的区别</h3><p>回答了get和post数据存放，get的不安全。感觉这里没答好，紧张的不知道怎么组织语言，哭了。</p><h3 id="6-如果给你一个登陆功能，你会怎么去测试它？"><a href="#6-如果给你一个登陆功能，你会怎么去测试它？" class="headerlink" title="6.如果给你一个登陆功能，你会怎么去测试它？"></a>6.如果给你一个登陆功能，你会怎么去测试它？</h3><p>没回答出来，问了面试官姐姐，学习了一下测试思维，感谢！</p><h3 id="7-对数据库有什么了解？"><a href="#7-对数据库有什么了解？" class="headerlink" title="7.对数据库有什么了解？"></a>7.对数据库有什么了解？</h3><p>回答了会基础SQL语句，索引，事务等，没想到面试官姐姐问SQL语句，好久没写过了，给自己挖坑了，居然没问索引和事务</p><h3 id="8-用SQL语句查询学生表分数大于80分的？"><a href="#8-用SQL语句查询学生表分数大于80分的？" class="headerlink" title="8.用SQL语句查询学生表分数大于80分的？"></a>8.用SQL语句查询学生表分数大于80分的？</h3><p>还好很基础，只不过好久没写，把from都写错了，太尴尬了</p><h3 id="9-用SQL语句查询学生表中按照分数排序后大于80分的学生姓名和分数？"><a href="#9-用SQL语句查询学生表中按照分数排序后大于80分的学生姓名和分数？" class="headerlink" title="9.用SQL语句查询学生表中按照分数排序后大于80分的学生姓名和分数？"></a>9.用SQL语句查询学生表中按照分数排序后大于80分的学生姓名和分数？</h3><p>还好，还是一样把form写错了，面试官姐姐问这题的时候提醒我的</p><h3 id="10-写算法题了，第一个是反转链表，第二个是输出数组中元素超过数组长度一般的元素，第三个是数组去重。"><a href="#10-写算法题了，第一个是反转链表，第二个是输出数组中元素超过数组长度一般的元素，第三个是数组去重。" class="headerlink" title="10.写算法题了，第一个是反转链表，第二个是输出数组中元素超过数组长度一般的元素，第三个是数组去重。"></a>10.写算法题了，第一个是反转链表，第二个是输出数组中元素超过数组长度一般的元素，第三个是数组去重。</h3><p>刚开始要求在输入框中写，直接让我懵了，然后用记事本写了，没写出来，手发抖，对代码还是不太熟练，得多练，后边跟面试官姐姐说只写核心代码部分。真是应了某群里金牌佬的口头ac了。（思路没问题，用了多种解法，分析了时间复杂度，但是就是没写出来，泪目）</p><h3 id="11-在项目过程中或者学校，分析自己的优势，相对于别人来说好在哪？"><a href="#11-在项目过程中或者学校，分析自己的优势，相对于别人来说好在哪？" class="headerlink" title="11.在项目过程中或者学校，分析自己的优势，相对于别人来说好在哪？"></a>11.在项目过程中或者学校，分析自己的优势，相对于别人来说好在哪？</h3><p>这里就不多说了</p><h3 id="12-为什么想要来测开岗位？"><a href="#12-为什么想要来测开岗位？" class="headerlink" title="12.为什么想要来测开岗位？"></a>12.为什么想要来测开岗位？</h3><p>开放题，过了过了</p><h3 id="13-反问：问了面试官姐姐对于本次面试的一些建议和测开岗位的认识，和如果过了，大概还有几次面试？"><a href="#13-反问：问了面试官姐姐对于本次面试的一些建议和测开岗位的认识，和如果过了，大概还有几次面试？" class="headerlink" title="13.反问：问了面试官姐姐对于本次面试的一些建议和测开岗位的认识，和如果过了，大概还有几次面试？"></a>13.反问：问了面试官姐姐对于本次面试的一些建议和测开岗位的认识，和如果过了，大概还有几次面试？</h3><p>需要培养测试的思维和意识，在平常生活中多怀疑，多尝试等<br>最少还有一轮</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次面试，确实还是太紧张了，虽然都是基础，基本也都回答上来了，但是说话不流畅，有结巴，放不开，表现不是很好，唉。<br>一面没有问到语言和项目，可能是做的开发的项目吧，就问了下怎么做的，没细聊。<br>最后感谢滴滴给予的面试机会，突破了自己，还有滴滴的面试官小姐姐，很温柔也很细心。<br>许愿一面能过吧！</p><p>博客同步：<a href="https://super0514.github.io/">没事请叫我去学习</a><br>每一场面试都要做一次总结复盘，也都会同步到博客网站，希望佬们点点赞，感谢感谢啦！</p>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法--二分查找（python实现）</title>
      <link href="/2022/02/21/suan-fa-er-fen-cha-zhao-python-shi-xian/"/>
      <url>/2022/02/21/suan-fa-er-fen-cha-zhao-python-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="1-算法介绍"><a href="#1-算法介绍" class="headerlink" title="1.算法介绍"></a>1.算法介绍</h2><p>二分查找法（Binary Search）算法，也叫折半查找算法。二分查找针对的是<strong>一个有序的数据集合</strong>，查找思想有点类似于分治思想。每次都通过跟区间的中间元素对比，将带查找的区间缩小为之前的一半，知道找到要查找的元素，或者区间被缩小为0。二分查找是一种非常非常高效的查询算法，时间复杂度未O(logn)。</p><p>基本算法思想：先确定待查找元素所在的区间范围，在逐步缩小范围，直到找到元素或找不到该元素为止。</p><h2 id="2-算法过程"><a href="#2-算法过程" class="headerlink" title="2.算法过程"></a>2.算法过程</h2><p>二分查找算法的过程如下所示：</p><ul><li>每次查找时从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；</li><li>如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。</li><li>如果在某一步骤数组为空，则代表找不到。</li></ul><p>举个例子来说，给定一个有序数组 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8]</code>。如果我们希望查找 <code>5</code> 是否在这个数组中。</p><ul><li>第一次区间为整个数组 <code>[0, 1, 2, 3, 4, 5, 6, 7, 8]</code>，中位数是 <code>4</code>，因为 <code>4</code> 小于 <code>5</code>，所以如果 <code>5</code> 存在在这个数组中，那么 <code>5</code> 一定在 <code>4</code> 右边的这一半区间中。于是我们的查找范围变成了 <code>[4, 5, 6, 7, 8]</code>。</li><li>第二次区间为 <code>[4, 5, 6, 7, 8]</code>，中位数是 <code>6</code>，因为 <code>5</code> 小于 <code>6</code>，所以如果 <code>5</code> 存在在这个数组中，那么 <code>5</code> 一定在 <code>6</code> 左边的这一半区间中。于是我们的查找范围变成了 <code>[4, 5, 6]</code>。</li><li>第三次区间为 <code>[4, 5, 6]</code>，中位数是 <code>5</code>，正好是我们需要查找的数字。</li></ul><p>于是我们发现，对于一个长度为 <code>9</code> 的有序数组，我们只进行了 <code>3</code> 次查找就找到了我们需要查找的数字。而如果是依次遍历数组，则最坏情况下，我们需要查找 <code>9</code> 次。</p><h2 id="3-简单例题"><a href="#3-简单例题" class="headerlink" title="3.简单例题"></a>3.简单例题</h2><p>【LeetCode】704.二分查找</p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [-1,0,3,5,9,12], target &#x3D; 9输出: 4解释: 9 出现在 nums 中并且下标为 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><p>二分查找解题：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        l<span class="token punctuation">,</span>r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span>                r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> mid        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-二分查找细节"><a href="#4-二分查找细节" class="headerlink" title="4.二分查找细节"></a>4.二分查找细节</h2><p>从上面的例子中我们了解了二分查找的思路和具体代码。但是真正在解决二分查找题目的时候还是需要考虑很多细节的。比如说以下几个问题：</p><ol><li>区间的开闭问题：区间应该是左闭右闭，还是左闭右开？</li><li><code>mid</code> 的取值问题：<code>mid = (left + right) // 2</code>，还是 <code>mid = (left + right + 1) // 2</code>？</li><li>出界条件的判断：<code>left &lt;= right</code>，还是 <code>left &lt; right</code>？</li><li>搜索区间范围的选择：<code>left = mid + 1</code>、<code>right = mid - 1</code>、 <code>left = mid </code>、<code>right = mid</code> 应该怎么写？</li></ol><p>下面一一讲解。</p><h3 id="区间的开闭问题"><a href="#区间的开闭问题" class="headerlink" title="区间的开闭问题"></a>区间的开闭问题</h3><p>区间的左闭右闭、左闭右开指的是初始待查找区间的范围。</p><ul><li>左闭右闭：初始化赋值时，<code>left = 0</code>，<code>right = len(nums) - 1</code>，<code>left</code> 为数组第一个元素位置，<code>right</code> 为数组最后一个元素位置，从而区间 <code>[left, right]</code> 左右边界上的点都能取到。</li><li>左闭右开：初始化赋值时，<code>left = 0</code>，<code>right = len(nums)</code>，<code>left</code> 为数组第一个元素位置，<code>right</code> 为数组最后一个元素的下一个位置，从而区间 <code>[left, right)</code> 左边界点能取到，而右边界上的点不能取到。</li></ul><p>关于左闭右闭、左闭右开，其实在网上都有对应的代码和解法。但是相对来说，左闭右开这种写法在解决问题的过程中，需要考虑的情况更加复杂，所以建议 <strong>全部使用「左闭右闭」区间</strong>。</p><h3 id="mid-的取值问题"><a href="#mid-的取值问题" class="headerlink" title="mid 的取值问题"></a><code>mid</code> 的取值问题</h3><p>在二分查找的实际问题中，最常见的 <code>mid</code> 取值就是 <code>mid = (left + right) // 2</code> 或者 <code>mid = left + (right - left) // 2 </code>。前者是最常见写法，<strong>后者是为了防止整型溢出</strong>。式子中 <code>// 2</code> 就代表的含义是中间数「向下取整」。当待查找区间中有偶数个元素个数时，则位于最中间的数为 <code>2</code> 个，这时候使用上面式子只能取到中间靠左边那个数，而取不到中间靠右边的那个数。那么，右边的那个数到底能取吗？</p><p>其实，右边的数也是可以取的，令 <code>mid = (left + right + 1) // 2</code>，或者 <code>mid = left + (right - left + 1) // 2</code>。这样如果待查找区间的元素为偶数个，就能取到中间靠右边的那个数了。</p><p>这是因为二分查找的思路是根据每次选择中间位置上的数值来决定下一次在哪个区间查找元素。每一次选择的元素位置可以是中间位置，但并不是一定非得是区间中间位置元素，靠左一些、靠右一些、甚至区间三分之一、五分之一处等等，都是可以的。比如说 <code>mid = left + (right - left + 1) * 1 // 5</code> 也是可以的。</p><p>但一般来说，取中间位置元素在平均意义下所达到的效果最好。同时这样写最简单。而对于 <code>mid</code> 值是向下取整还是向上取整，大多数时候是选择不加 <code>1</code>。但有些写法中，是需要考虑加 <code>1</code> 的，这个后面会说这种写法。</p><h3 id="出界条件的判断"><a href="#出界条件的判断" class="headerlink" title="出界条件的判断"></a>出界条件的判断</h3><p>我们经常看到二分查找算法的写法中，<code>while</code> 语句出界判断的语句有<code>left &lt;= right</code> 和 <code>left &lt; right</code> 两种写法。那我们究竟应该在什么情况用什么写法呢？</p><ul><li>如果判断语句为 <code>left &lt;= right</code>，且查找的元素不存在，则 <code>while</code> 判断语句出界条件是 <code>left == right + 1</code>，写成区间形式就是 <code>[right + 1, right]</code>，此时待查找区间为空，待查找区间中没有元素存在，所以此时终止循环可以直接返回 <code>-1</code> 是正确的。<ul><li>比如说区间 <code>[3, 2]</code>，不可能存在一个元素既大于等于 <code>3</code> 又小于等于 <code>2</code>，此时直接终止循环，返回 <code>-1</code> 即可。</li></ul></li><li>如果判断语句为<code>left &lt; right</code>，且查找的元素不存在，则 <code>while</code> 判断语句出界条件是 <code>left == right</code>，写成区间形式就是 <code>[right, right]</code>。此时区间不为空，待查找区间还有一个元素存在，并不能确定查找的元素不在这个区间中，此时终止循环返回 <code>-1</code> 是错误的。<ul><li>比如说区间 <code>[2, 2]</code>，元素 <code>2</code> 就属于这个区间，此时终止循环，返回 <code>-1</code> 就漏掉了这个元素。</li></ul></li></ul><p>但是如果我们还是想要使用 <code>left &lt; right</code> 的话，怎么办？</p><p>可以在返回的时候需要增加一层判断，判断 <code>left</code> 所指向位置是否等于目标元素，如果是的话就返回 <code>left</code>，如果不是的话返回 <code>-1</code>。即：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># ...</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        <span class="token comment"># ...</span>    <span class="token keyword">return</span> left <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>此外，用 <code>left &lt; right</code> 的话还有一个好处，就是退出循环的时候 <code>left == right</code> 成立，就不用判断应该返回 <code>left</code> 还是 <code>right</code> 了。</p><h3 id="搜索区间范围的选择"><a href="#搜索区间范围的选择" class="headerlink" title="搜索区间范围的选择"></a>搜索区间范围的选择</h3><p>在进行区间范围选择的时候，有时候是 <code>left = mid + 1</code>、<code>right = mid - 1</code>，还有的时候是 <code>left = mid + 1 </code>、<code>right = mid</code>，还有的时候是 <code>left = mid</code>、<code>right = mid - 1</code>。那么我们到底应该如何确定搜索区间范围呢？</p><p>这是二分查找的一个难点，写错了<strong>很容易造成死循环</strong>，或者得不到正确结果。</p><p>这其实跟二分查找算法的两种不同思路有关。</p><ul><li>思路 1：「直接找」—— 在循环体中找到元素后直接返回结果。</li><li>思路 2：「排除法」—— 在循环体中排除目标元素一定不存在区间。</li></ul><h2 id="二分查找两种思路"><a href="#二分查找两种思路" class="headerlink" title="二分查找两种思路"></a>二分查找两种思路</h2><h3 id="思路-1：「直接找」"><a href="#思路-1：「直接找」" class="headerlink" title="思路 1：「直接找」"></a>思路 1：「直接找」</h3><p>第 1 种思路比较简单，一旦我们在循环体中找到元素就直接返回结果。其实我们在上边 「3. 简单二分查找 - [704. 二分查找」 中就已经用过了。这里再看一下思路和代码：</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ul><li>取两个节点中心位置 <code>mid</code>，先看中心位置值 <code>nums[mid]</code>。<ul><li>如果中心位置值 <code>nums[mid]</code> 与目标值 <code>target</code> 相等，则 <strong>直接返回</strong> 这个中心位置元素的下标。</li><li>如果中心位置值 <code>nums[mid]</code> 小于目标值 <code>target</code>，则将左节点设置为 <code>mid + 1</code>，然后继续在右区间 <code>[mid + 1, right]</code> 搜索。</li><li>如果中心位置值 <code>nums[mid]</code> 大于目标值 <code>target</code>，则将右节点设置为 <code>mid - 1</code>，然后继续在左区间 <code>[left, mid - 1]</code> 搜索。</li></ul></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment"># 在区间 [left, right] 内查找 target</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            <span class="token comment"># 取区间中间节点</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment"># 如果找到目标值，则直接范围中心位置</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token comment"># 如果 nums[mid] 小于目标值，则在 [mid + 1, right] 中继续搜索</span>            <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token comment"># 如果 nums[mid] 大于目标值，则在 [left, mid - 1] 中继续搜索</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment"># 未搜索到元素，返回 -1</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="细节："><a href="#细节：" class="headerlink" title="细节："></a>细节：</h4><ul><li>这种思路是在一旦循环体中找到元素就直接返回。</li><li>循环可以继续的条件是 <code>left &lt;= right</code>。</li><li>如果一旦退出循环，则说明这个区间内一定不存在目标元素。</li></ul><h3 id="5-2-思路-2：「排除法」"><a href="#5-2-思路-2：「排除法」" class="headerlink" title="5.2 思路 2：「排除法」"></a>5.2 思路 2：「排除法」</h3><p>第 2 种思路在循环体中排除目标元素一定不存在区间。</p><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><ul><li>取两个节点中心位置 <code>mid</code>，根据判断条件先将目标元素一定不存在的区间排除。</li><li>然后在剩余区间继续查找元素，继续根据条件排除不存在的区间。</li><li>直到区间中只剩下最后一个元素，然后再判断这个元素是否是目标元素。</li></ul><p>根据第二种排除法的思路，我们可以写出来两种代码。</p><p>第一种代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment"># 在区间 [left, right] 内查找 target</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment"># 取区间中间节点</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment"># nums[mid] 小于目标值，排除掉不可能区间 [left, mid]，在 [mid + 1, right] 中继续搜索</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>             <span class="token comment"># nums[mid] 大于等于目标值，目标元素可能在 [left, mid] 中，在 [left, mid] 中继续搜索</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid        <span class="token comment"># 判断区间剩余元素是否为目标元素，不是则返回 -1</span>        <span class="token keyword">return</span> left <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二种代码：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">search</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">0</span>        right <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token comment"># 在区间 [left, right] 内查找 target</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>            <span class="token comment"># 取区间中间节点</span>            mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            <span class="token comment"># nums[mid] 大于目标值，排除掉不可能区间 [mid, right]，在 [left, mid - 1] 中继续搜索</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>             <span class="token comment"># nums[mid] 小于等于目标值，目标元素可能在 [mid, right] 中，在 [mid, right] 中继续搜索</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> mid        <span class="token comment"># 判断区间剩余元素是否为目标元素，不是则返回 -1</span>        <span class="token keyword">return</span> left <span class="token keyword">if</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token keyword">else</span> <span class="token operator">-</span><span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="细节：-1"><a href="#细节：-1" class="headerlink" title="细节："></a>细节：</h4><ul><li>判断语句是 <code>left &lt; right</code>。这样在退出循环时，一定有<code>left == right</code> 成立，就不用判断应该返回 <code>left</code> 还是 <code>right</code> 了。同时方便定位查找元素的下标。但是一定要注意最后要对区间剩余的元素进行一次判断。</li><li>在循环体中，优先考虑 <code>nums[mid]</code> 在什么情况下一定不是目标元素，排除掉不可能区间，然后再从剩余区间中确定下一次查找区间的范围。</li><li>在考虑 <code>nums[mid]</code> 在什么情况下一定不是目标元素之后，它的对立面（即 <code>else</code> 部分）一般就不需要再考虑区间范围了，直接取上一个区间的反面区间。如果上一个区间是 <code>[mid + 1, right]</code>，那么相反面就是 <code>[left, mid]</code>。如果上一个区间是 <code>[left, mid - 1]</code>，那么相反面就是 <code>[mid, right]</code>。</li><li>区分被分为两部分： <code>[left, mid - 1]</code> 与 <code>[mid, right]</code> 时，<strong>mid 取值要向上取整</strong>。即 <code>mid = left + (right - left + 1) // 2</code>。因为如果当区间中只剩下两个元素时（此时 <code>right = left + 1</code>），一旦进入 <code>left = mid</code> 分支，区间就不会再缩小了，下一次循环的查找区间还是 <code>[left, right]</code>，就陷入了死循环。</li><li>关于边界设置可以记忆为：只要看到 <code>left = mid</code> 就向上取整。或者记为：<ul><li><code>left = mid + 1</code> 和 <code>right = mid</code> 和 <code>mid = left + (right - left) // 2</code> 一定是配对出现的。</li><li><code>right = mid - 1</code> 和 <code>left = mid</code> 和 <code>mid = left + (right - left + 1) // 2</code> 一定是配对出现的。</li></ul></li></ul><h3 id="5-3-两种思路适用范围"><a href="#5-3-两种思路适用范围" class="headerlink" title="5.3 两种思路适用范围"></a>5.3 两种思路适用范围</h3><ul><li>二分查找的思路 1：因为判断语句是 <code>left &lt;= right</code>，有时候要考虑返回是 <code>left</code> 还是 <code>right</code>。循环体内有 3 个分支，并且一定有一个分支用于退出循环或者直接返回。<strong>这种思路适合解决简单题目。即要查找的元素性质简单，数组中都是非重复元素</strong>，且 <code>==</code>、<code>&gt;</code>、<code>&lt;</code> 的情况非常好写的时候。</li><li>二分查找的思路 2：更加<strong>符合二分查找算法的减治思想。每次排除目标元素一定不存在的区间，达到减少问题规模的效果</strong>。然后在可能存在的区间内继续查找目标元素。这种思路适合解决复杂题目。比如查找一个数组里可能不存在的元素，找边界问题，可以使用这种思路。</li></ul><h2 id="6-案例实现："><a href="#6-案例实现：" class="headerlink" title="6.案例实现："></a>6.案例实现：</h2><h3 id="二分下标题目"><a href="#二分下标题目" class="headerlink" title="二分下标题目"></a>二分下标题目</h3><p>【LeetCode】374. 猜数字大小</p><p>猜数字游戏的规则如下：</p><ul><li>每轮游戏，我都会从 <strong>1</strong> 到 <strong>*n</strong>* 随机选择一个数字。 请你猜选出的是哪个数字。</li><li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li></ul><p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p><ul><li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li><li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li><li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li></ul><p>返回我选出的数字。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入：n &#x3D; 10, pick &#x3D; 6输出：6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>题解：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">guessNumber</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        left <span class="token operator">=</span> <span class="token number">1</span>        right <span class="token operator">=</span> n        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>            ret <span class="token operator">=</span> guess<span class="token punctuation">(</span>mid<span class="token punctuation">)</span>            <span class="token keyword">if</span> ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> mid            <span class="token keyword">elif</span> ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二分答案题目"><a href="#二分答案题目" class="headerlink" title="二分答案题目"></a>二分答案题目</h3><p>【LeetCode】69. x 的平方根</p><p>给你一个非负整数 <code>x</code> ，计算并返回 <code>x</code> 的 <strong>算术平方根</strong> 。</p><p>由于返回类型是整数，结果只保留 **整数部分 **，小数部分将被 <strong>舍去 。</strong></p><p><strong>注意：</strong>不允许使用任何内置指数函数和算符，例如 <code>pow(x, 0.5)</code> 或者 <code>x ** 0.5</code> 。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入：x &#x3D; 4输出：2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>题解：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">mySqrt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        l<span class="token punctuation">,</span>r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>x<span class="token operator">/</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>        <span class="token keyword">while</span> l <span class="token operator">&lt;=</span> r<span class="token punctuation">:</span>            mid <span class="token operator">=</span> <span class="token punctuation">(</span>l<span class="token operator">+</span>r<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span>            <span class="token keyword">if</span> mid <span class="token operator">></span> x<span class="token operator">/</span>mid<span class="token punctuation">:</span>                r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">elif</span> mid <span class="token operator">&lt;</span> x<span class="token operator">/</span>mid<span class="token punctuation">:</span>                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>思考：对于二分查找的使用主要还是在范围的定界和判断的条件处存在问题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法--常见十大排序算法（python实现）</title>
      <link href="/2022/02/21/suan-fa-chang-jian-shi-da-pai-xu-suan-fa-python-shi-xian/"/>
      <url>/2022/02/21/suan-fa-chang-jian-shi-da-pai-xu-suan-fa-python-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><h2 id="算法思想："><a href="#算法思想：" class="headerlink" title="算法思想："></a>算法思想：</h2><blockquote><p>第 <code>i (i = 1，2，… )</code> 趟排序时从序列中前 <code>n - i + 1</code> 个元素的第 <code>1</code> 个元素开始，相邻两个元素进行比较，若前者大于后者，两者交换位置，否则不交换。</p></blockquote><p>冒泡排序法是<strong>通过相邻元素之间的比较与交换</strong>，使值较小的元素逐步从后面移到前面，值较大的元素从前面移到后面，就像水底的气泡一样向上冒，故称这种排序方法为冒泡排序法。</p><h2 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>先将序列中第 <code>1</code> 个元素与第 <code>2</code> 个元素进行比较，若前者大于后者，则两者交换位置，否则不交换；</li><li>然后将第 <code>2</code> 个元素与第 <code>3</code> 个元素比较，若前者大于后者，则两者交换位置，否则不交换；</li><li>依次类推，直到第 <code>n - 1</code> 个元素与第 <code>n</code> 个元素比较（或交换）为止。经过如此一趟排序，使得 <code>n</code> 个元素中值最大元素被安置在序列的第 <code>n</code> 个位置上。</li><li>此后，再对前 <code>n - 1</code> 个元素进行同样过程，使得该 <code>n - 1</code> 个元素中值最大元素被安置在第 <code>n - 1</code> 个位置上。</li><li>然后再对前 <code>n - 2</code> 个元素重复上述过程，直到某一趟排序过程中不出现元素交换位置的动作，排序结束。</li></ul><h2 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>最好的情况下，初始时序列<strong>已经是从小到大有序（升序）</strong>，则只需经过一趟 <code>n - 1</code> 次元素之间的比较，并且不移动元素，算法就可结束排序。此时，算法的时间复杂度为 O(n)。</li><li>最差的情况是当参加排序的初始序列为逆序，或者<strong>最小值元素处在序列的最后时，则需要进行 <code>n - 1</code> 趟排序</strong>，总共进行 ∑i&#x3D;2n(i−1)&#x3D;n(n−1)&#x2F;2 次元素之间的比较，因此，冒泡排序算法的平均时间复杂度为 O(n**2)。</li><li>冒泡排序方法在排序过程中需要移动较多次数的元素。因此，<strong>冒泡排序方法比较适合于参加排序序列的数据量较小的情况</strong>，尤其是当序列的初始状态为基本有序的情况；而对于一般情况，这种方法是排序时间效率最低的一种方法。</li><li>由于元素交换是在相邻元素之间进行的，不会改变值相同元素的相对位置，因此，冒泡排序法是一种 <strong>稳定排序法</strong>。</li></ul><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>          arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>              <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>bubbleSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现："><a href="#案例实现：" class="headerlink" title="案例实现："></a>案例实现：</h2><p>【LeetCode】283.移动零</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入: nums &#x3D; [0,1,0,3,12]输出: [1,3,12,0,0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>使用冒泡排序解题：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span>      <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果是错误的：</p><blockquote><p>输入：</p><p>[0,1,0,3,12]</p><p>输出：</p><p>[12,3,1,0,0]</p><p>预期结果：</p><p>[1,3,12,0,0]</p></blockquote><p>​    原来我们题目要求是要保证原数字相对位置不改变，但是我们冒泡算法的书写是没问题的，不过并不常用。</p><h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><h2 id="算法思想：-1"><a href="#算法思想：-1" class="headerlink" title="算法思想："></a>算法思想：</h2><blockquote><p>第 <code>i</code> 趟排序从序列的后 <code>n − i + 1 (i = 1, 2, …, n − 1)</code> 个元素中选择一个值最小的元素与该 <code>n - i + 1</code> 个元素的最前面那个元素交换位置，即与整个序列的第 <code>i</code> 个位置上的元素交换位置。如此下去，直到 <code>i == n − 1</code>，排序结束。</p></blockquote><p>可以简述为：<strong>每一趟排序中，从剩余未排序元素中选择一个最小的元素，与未排好序的元素最前面的那个元素交换位置。</strong></p><h2 id="算法步骤：-1"><a href="#算法步骤：-1" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>在算法中设置整型变量 <code>i</code>，既可以作为排序趟数的计算，同时也作为执行第 <code>i</code> 趟排序时，参加排序的后 <code>n − i + 1</code> 个元素的第 <code>1</code> 个元素的位置。</li><li>整型变量 <code>min_i</code> 记录这 <code>n − i + 1</code> 个元素中值最小元素的位置。</li><li>每一趟排序开始，先另 <code>min_i = i</code> （即暂时假设序列的第 <code>i</code> 个元素为值最小者，以后经过比较后视实际情况再正式确定最小值元素的位置）。</li><li>第 <code>i</code> 趟排序比较结束时，这 <code>n − i + 1</code> 个元素中真正的值最小元素为下标 <code>min_i</code> 对应的元素。此时，若有 <code>min_i == i</code>，说明值最小元素就是这 <code>n − i + 1</code> 个元素的第 <code>1</code> 个元素，意味着此趟排序不必进行元素交换。</li></ul><h2 id="算法分析：-1"><a href="#算法分析：-1" class="headerlink" title="算法分析："></a>算法分析：</h2><p>对于具有 <code>n</code> 个元素的序列采用选择排序方法要经过 <code>n - 1</code> 趟排序。</p><ul><li>当原始序列是一个按值递增序列（升序）时，元素的移动次数最少，为 <code>0</code> 次。当序列初始时是一个按值递减序列（逆序）时，元素的移动次数最多，为 3(n−1) 次（<code>3</code> 是交换 <code>arr[i]</code> 与 <code>arr[min_i]</code> 的执行次数）。</li><li>但是，无论序列中元素的初始排列状态如何，第 <code>i</code> 趟排序要找出值最小元素都需要进行 <code>n − i</code> 次元素之间的比较。因此，整个排序过程需要进行的元素之间的比较次数都相同，为 ∑i&#x3D;2n(i−1)&#x3D;n(n−1)&#x2F;2 次。</li><li>这说明选择排序法所进行的元素之间的比较次数与序列的原始状态无关，同时可以确定算法的时间复杂度为 O(n**2)。</li><li><strong>由于值最小元素与未排好序的元素中第 <code>1</code> 个元素的交换动作是在不相邻的元素之间进行的，因此很有可能会改变值相同元素的前后位置，</strong>因此，选择排序法是一种不稳定的排序方法。</li></ul><h2 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      min_i <span class="token operator">=</span> i      <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min_i<span class="token punctuation">]</span><span class="token punctuation">:</span>          min_i <span class="token operator">=</span> j      <span class="token keyword">if</span> i <span class="token operator">!=</span> min_i<span class="token punctuation">:</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>min_i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min_i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>   <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>selectionSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-1"><a href="#案例实现：-1" class="headerlink" title="案例实现："></a>案例实现：</h2><p>【LeetCode】215. 数组中的第K个最大元素</p><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入: [3,2,1,5,6,4] 和 k &#x3D; 2输出: 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>使用选择排序解题：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findKthLargest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> k<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            min_i <span class="token operator">=</span> i            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>min_i<span class="token punctuation">]</span><span class="token punctuation">:</span>                    min_i <span class="token operator">=</span> j            <span class="token keyword">if</span> i <span class="token operator">!=</span> min_i<span class="token punctuation">:</span>                nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>min_i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>min_i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>      <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token operator">-</span>k<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将数组排序后取第k大的元素，但是这样的结果花费的时间特别长，使用的也并不常见。</p><h1 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h1><h2 id="算法思想：-2"><a href="#算法思想：-2" class="headerlink" title="算法思想："></a>算法思想：</h2><blockquote><p>将整个序列切分为两部分：前 <code>i - 1</code> 个元素是有序序列，后 <code>n - i + 1</code> 个元素是无序序列。每一次排序，将无序序列的首元素，在有序序列中找到相应的位置并插入。</p></blockquote><p>可以简述为：<strong>每一趟排序中，将剩余无序序列的第一个元素，插入到有序序列的适当位置上</strong>。</p><h2 id="算法步骤：-2"><a href="#算法步骤：-2" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>将第一个元素作为一个有序序列，将第 <code>2 ~ n - 1</code> 个元素作为无序序列。</li><li>从头至尾一次扫描无序序列，将扫描到的每个元素插入到有序序列的适当位置上。</li></ul><h2 id="算法分析：-2"><a href="#算法分析：-2" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>对于具有 <code>n</code> 个元素的序列，插入排序方法一共要进行 <code>n - 1</code> 趟排序。</li><li>对于插入排序算法，整个排序过程只需要一个辅助空间 <code>temp</code>。</li><li>当原始序列是一个按值递增序列（升序）时，对应的每个 <code>i</code> 值只进行一次元素之间的比较，因而总的比较次数最少，为 ∑i&#x3D;2n1&#x3D;n−1，并不需要移动元素（记录），这是最好的情况。</li><li>最坏的情况是，序列初始时是一个按值递减序列（逆序），则对应的每个 <code>i</code> 值都要进行 <code>i - 1</code> 次元素之间的比较，总的元素之间的比较次数达到最大值，为 ∑i&#x3D;2n(i−1)&#x3D;n(n−1)&#x2F;2。</li><li>如果序列的初始情况是随机的，即参加排序的序列中元素可能出现的各种排列的概率相同，则可取上述最小值和最大值的平均值作为插入排序时所进行的元素之间的比较次数，约为 n2&#x2F;4。由此得知，插入排序算法的时间复杂度 O(n**2)。</li><li>插入排序方法属于稳定性排序方法。</li></ul><h2 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>      j <span class="token operator">=</span> i      <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>        j <span class="token operator">-=</span> <span class="token number">1</span>      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp    <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>insertionSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-2"><a href="#案例实现：-2" class="headerlink" title="案例实现："></a>案例实现：</h2><p>【LeetCode】75. 颜色分类</p><p>给定一个包含红色、白色和蓝色、共 <code>n</code>* *个元素的数组 <code>nums</code> ，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p><p>必须在不使用库的sort函数的情况下解决这个问题。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [2,0,2,1,1,0]输出：[0,0,1,1,2,2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>使用插入排序解题：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortColors</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>      <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>         temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span>         j <span class="token operator">=</span> i         <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>             nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>             j <span class="token operator">-=</span> <span class="token number">1</span>         nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp      <span class="token keyword">return</span> nums<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入排序也是一个比较耗时的方法，一般这类题目也比较少，不是很常见。</p><h1 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h1><h2 id="算法思想：-3"><a href="#算法思想：-3" class="headerlink" title="算法思想："></a>算法思想：</h2><p>将整个序列切按照一定的间隔取值划分为若干个子序列，每个子序列分别进行插入排序。然后逐渐缩小间隔进行下一轮划分子序列和插入排序。直至最后一轮排序间隔为 <code>1</code>，对整个序列进行插入排序。</p><h2 id="算法步骤：-3"><a href="#算法步骤：-3" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li><p>首先确定一个元素间隔数 <code>gap</code>，然后将参加排序的序列按此间隔数从第 <code>1</code> 个元素开始一次分成若干个子序列，即分别将所有位置相隔为 <code>gap</code> 的元素视为一个子序列，在各个子序列中采用某种排序方法进行插入排序。</p></li><li><p>然后减少间隔数，并重新将整个序列按新的间隔数分成若干个子序列，再分别对各个子序列进行排序，如此下去，直到间隔数 <code>gap = 1</code>。</p><p>​</p></li></ul><h2 id="算法分析：-3"><a href="#算法分析：-3" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li><p>希尔排序方法的速度是一系列间隔数 gapi 的函数，不太容易弄清楚比较次数与 <code>gap</code> 之间的依赖关系，并给出完整的数学分析。</p></li><li><p>上面算法中，由于采用 gapi&#x3D;⌊gapi−1&#x2F;2⌋ 的方法缩小间隔数，对于具有 <code>n</code> 个元素的序列，若 gap1&#x3D;⌊n&#x2F;2⌋，则经过 p&#x3D;⌊log2n⌋ 趟排序后就有 gapp&#x3D;1，因此，希尔排序方法的排序总躺数为 ⌊log2n⌋。</p></li><li><p>从算法中也可以看到，最外层的 while 循环为 log2n 数量级，中间层 do-while 循环为 <code>n</code> 数量级。当子序列分得越多时，子序列内的元素就越少，最内层的 for 循环的次数也就越少；反之，当所分的子序列个数减少时，子序列内的元素也随之增多，但整个序列也逐步接近有序，而循环次数却不会随之增加。因此，希尔排序算法的时间复杂度在 O(nlog2n) 与 O(n2) 之间。</p></li><li><p>希尔排序方法是一种不稳定排序算法。</p><p>​</p></li></ul><h2 id="代码实现：-3"><a href="#代码实现：-3" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        gap <span class="token operator">=</span> size <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">while</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>gap<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>                temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                j <span class="token operator">=</span> i                <span class="token keyword">while</span> j <span class="token operator">>=</span> gap <span class="token keyword">and</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> gap<span class="token punctuation">]</span>                    j <span class="token operator">-=</span> gap                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp            gap <span class="token operator">=</span> gap <span class="token operator">//</span> <span class="token number">2</span>        <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>shellSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-3"><a href="#案例实现：-3" class="headerlink" title="案例实现："></a>案例实现：</h2><p>了解即可，时间复杂度上稍微比前面的排序方法快一些，但是也几乎不使用该排序方法。</p><h1 id="五、归并排序"><a href="#五、归并排序" class="headerlink" title="五、归并排序"></a>五、归并排序</h1><h2 id="算法思想：-4"><a href="#算法思想：-4" class="headerlink" title="算法思想："></a>算法思想：</h2><p>采用经典的分治策略，先递归地将当前序列平均分成两半，直到所有的子序列长度都为1，然后将有序序列两两合并，最终合并成一个有序序列。</p><h2 id="算法步骤：-4"><a href="#算法步骤：-4" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>初始时，将待排序序列中的 <code>n</code> 个记录看成 <code>n</code> 个有序子序列（每个子序列总是有序的），每个子序列的长度均为 <code>1</code>。</li><li>把当前序列组中有序子序列两两归并，完成一遍之后序列组里的排序序列个数减半，每个子序列的长度加倍。</li><li>对长度加倍的有序子序列重复上面的操作，最终得到一个长度为 <code>n</code> 的有序序列。</li></ul><h2 id="算法分析：-4"><a href="#算法分析：-4" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>归并排序算法的时间复杂度<strong>等于归并趟数与每一趟归并的时间复杂度成绩</strong>。子算法 <code>merge(left_arr, right_arr):</code> 的时间复杂度是 O(n)，因此，归并排序算法总的**时间复杂度为 O(nlog2n)**。</li><li>归并排序方法需要用到与参加排序的序列同样大小的辅助空间。因此算法的空间复杂度为 O(n)。</li><li>因为在两个有序子序列的归并过程中，如果两个有序序列中出现相同元素，<code>merge(left_arr, right_arr):</code> 算法能够使前一个序列中那个相同元素先被复制，从而确保这两个元素的相对次序不发生改变。所以归并排序算法是 <strong>稳定排序算法</strong>。</li></ul><h2 id="代码实现：-4"><a href="#代码实现：-4" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token comment">#子序列排序函数</span>  <span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>left_arr<span class="token punctuation">,</span>right_arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> left_arr <span class="token keyword">and</span> right_arr<span class="token punctuation">:</span>      <span class="token keyword">if</span> left_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right_arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>           arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left_arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">#如果左边小于右边，则将小于的推入arr中，循环比较，直到此子序列全部排序完成</span>      <span class="token keyword">else</span><span class="token punctuation">:</span>        arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right_arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> left_arr<span class="token punctuation">:</span>      arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left_arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> right_arr<span class="token punctuation">:</span>      arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right_arr<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> size <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> arr    mid <span class="token operator">=</span> size<span class="token operator">//</span><span class="token number">2</span>    left_arr<span class="token punctuation">,</span>right_arr <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">:</span><span class="token punctuation">]</span>   <span class="token comment">#将序列分成两半</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>merge<span class="token punctuation">(</span>self<span class="token punctuation">.</span>mergeSort<span class="token punctuation">(</span>left_arr<span class="token punctuation">)</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>mergeSort<span class="token punctuation">(</span>right_arr<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>mergeSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-4"><a href="#案例实现：-4" class="headerlink" title="案例实现："></a>案例实现：</h2><p>做了力扣上的一道叫合并排序的数组，两个数组合并后排序，但是用归并没做出来，不是因为两个数组的问题，而是因为归并数组算法思想是分而治之，递归思想，在两个数组下，没有搞明白如何去递归，导致最后没能写出来。</p><h1 id="六、快速排序"><a href="#六、快速排序" class="headerlink" title="六、快速排序"></a>六、快速排序</h1><h2 id="算法思想：-5"><a href="#算法思想：-5" class="headerlink" title="算法思想："></a>算法思想：</h2><p>快速排序，又称划分交换排序，从无序队列中挑取一个元素，把无序队列分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h2 id="算法步骤：-5"><a href="#算法步骤：-5" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>从数组中随机找到一个基准数。</li><li>然后将数组中比基准数大的元素移动到基准数右侧，比他小的元素移动到基准数左侧，从而把数组拆分为左右两个部分。</li><li>再对左右两个部分分别重复第二步，直到各个部分只有一个数，则排序结束。</li></ul><h2 id="算法分析：-5"><a href="#算法分析：-5" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li><p>在参加排序的元素初始时已经有序的情况下，快速排序方法花费的时间最长。此时，第 <code>1</code> 趟排序经过 <code>n - 1</code> 次比较以后，将第 <code>1</code> 个元素仍然确定在原来的位置上，并得到 <code>1</code> 个长度为 <code>n - 1</code> 的子序列；第 <code>2</code> 趟排序进过 <code>n - 2</code> 次比较以后，将第 <code>2</code> 个元素确定在它原来的位置上，又得到 <code>1</code> 个长度为 <code>n - 2</code> 的子序列；依次类推，最终总的比较次数为 (n−1)+(n−2)+…+1&#x3D;n(n−1)&#x2F;2。因此时间复杂度为 O(n2)。</p></li><li><p>还有一种情况，若每趟排序后，分界元素正好定位在序列的中间，从而把当前参加排序的序列分成大小相等的前后两个子序列，则对长度为 n 的序列进行快速排序所需要的时间为：</p><p>T(n)≤ n+2T(n&#x2F;2) ≤ 2n+4T(n&#x2F;2) ≤ 3n+8T(n&#x2F;8) …… ≤ (log2n)n+nT(1)&#x3D;O(nlog2n)</p><p>因此，快速排序方法的时间复杂度为 O(nlog2n)，时间性能显然优于前面讨论的几种排序算法。</p></li><li><p>无论快速排序算法递归与否，排序过程中都需要用到堆栈或其他结构的辅助空间来存放当前待排序序列的首、尾位置。最坏的情况下，空间复杂度为 O(n)。</p></li><li><p>若对算法进行一些改写，在一趟排序之后比较被划分所得到的两个子序列的长度，并且首先对长度较短的子序列进行快速排序，这时候需要的空间复杂度可以达到 O(log2n)。</p></li><li><p>快速排序时一种 <strong>不稳定排序算法</strong>，也是一种<strong>不适合在链表结构上实现的排序算法</strong>。</p></li></ul><h2 id="代码实现：-5"><a href="#代码实现：-5" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>  <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>nums<span class="token punctuation">:</span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span>List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>quick_sort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>arr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 分治 一分为二</span>    <span class="token comment"># start=end ,证明要处理的数据只有一个</span>    <span class="token comment"># start>end ,证明右边没有数据</span>    <span class="token keyword">if</span> low <span class="token operator">>=</span> high<span class="token punctuation">:</span>        <span class="token keyword">return</span>    <span class="token comment"># 定义两个游标，分别指向0和末尾位置</span>    left <span class="token operator">=</span> low    right <span class="token operator">=</span> high    <span class="token comment"># 把0位置的数据，认为是中间值</span>    mid <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        <span class="token comment"># 让右边游标往左移动，目的是找到小于mid的值，放到left游标位置</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token keyword">and</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> mid<span class="token punctuation">:</span>            right <span class="token operator">-=</span> <span class="token number">1</span>        arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span>        <span class="token comment"># 让左边游标往右移动，目的是找到大于mid的值，放到right游标位置</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;</span> right <span class="token keyword">and</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> mid<span class="token punctuation">:</span>            left <span class="token operator">+=</span> <span class="token number">1</span>        arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span>    <span class="token comment"># while结束后，把mid放到中间位置，left=right</span>    arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> mid    <span class="token comment"># 递归处理左边的数据</span>    quick_sort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 递归处理右边的数据</span>    quick_sort<span class="token punctuation">(</span>li<span class="token punctuation">,</span> left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-5"><a href="#案例实现：-5" class="headerlink" title="案例实现："></a>案例实现：</h2><p>【LeetCode】912.排序数组</p><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入：nums &#x3D; [5,2,3,1]输出：[1,2,3,5]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><p>快速排序方法解题：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>            flag<span class="token operator">=</span>nums<span class="token punctuation">[</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">//</span><span class="token number">2</span><span class="token punctuation">]</span>              <span class="token comment">#每次从中间初始化哨兵位置</span>            i<span class="token punctuation">,</span>j<span class="token operator">=</span>left<span class="token punctuation">,</span>right                          <span class="token comment">#设定从左到右的指针i，从右到左的指针j</span>            <span class="token keyword">while</span> i<span class="token operator">&lt;=</span>j<span class="token punctuation">:</span>                <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>flag<span class="token punctuation">:</span> i<span class="token operator">+=</span><span class="token number">1</span>            <span class="token comment">#i从左往右扫，找到大于等于flag的数。</span>                <span class="token keyword">while</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>flag<span class="token punctuation">:</span> j<span class="token operator">-=</span><span class="token number">1</span>            <span class="token comment">#j从右往左扫，找到小于等于flag的数。</span>                <span class="token keyword">if</span> i<span class="token operator">&lt;=</span>j<span class="token punctuation">:</span>                    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token comment">#交换左右指针下标对应的数值</span>                    i<span class="token operator">+=</span><span class="token number">1</span>                            <span class="token comment">#左指针继续往右走</span>                    j<span class="token operator">-=</span><span class="token number">1</span>                            <span class="token comment">#右指针继续往左走</span>            <span class="token keyword">if</span> i<span class="token operator">&lt;</span>right<span class="token punctuation">:</span> quicksort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>i<span class="token punctuation">,</span>right<span class="token punctuation">)</span>     <span class="token comment">#递归解决flag左边的低位数组的排序</span>            <span class="token keyword">if</span> j<span class="token operator">></span>left<span class="token punctuation">:</span>  quicksort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span>left<span class="token punctuation">,</span>j<span class="token punctuation">)</span>      <span class="token comment">#递归解决flag右边的低位数组的排序</span>        quicksort<span class="token punctuation">(</span>nums<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token builtin">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>               <span class="token comment">#函数入口，将整个数组的信息传入</span>        <span class="token keyword">return</span> nums                                 <span class="token comment">#返回修改后的nums</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>快排主要搞定对范围判定及递归过程的理解</p><h1 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h1><h2 id="算法思想：-6"><a href="#算法思想：-6" class="headerlink" title="算法思想："></a>算法思想：</h2><p>堆顶（小顶堆）的元素是整个堆中最小的元素，将堆顶元素与最后一个元素交换，然后用一次‘向下筛选’将新的堆顶元素移动到堆中正确的位置：即比较堆顶元素与其两个左右子结点的大小，如果堆顶元素最小，则将其保留在堆顶位置，停止；如果左子结点或右子结点最小，则交换堆顶元素与左子结点或右子结点的值，然后再沿着当前路径不断地比较下去，直至最初的堆顶元素在某一次比较中是最小值或者到达叶结点位置。</p><p>此外，如果是小顶堆，得到的是降序序列；如果是大顶堆，得到的是升序序列。</p><blockquote><p>堆可以看作一棵完全二叉树，这棵二叉树满足，任何一个非叶节点的值都不大于（或不小于）其左右孩子节点的值</p></blockquote><h2 id="算法步骤：-6"><a href="#算法步骤：-6" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>堆排序需要解决两个问题：</p><ul><li>如何由一个无序序列建成一个堆</li><li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li></ul><p>针对第二个问题：一般在输出堆顶元素之后，视为将这个元素排除，然后用表中<strong>最后一个元素</strong>填补它的位置，自上向下进行调整：首先将堆顶元素和它的左右子树的根结点进行比较，把最小的元素交换到堆顶；然后顺着被破坏的路径一路调整下去，直至叶子结点，就得到新的堆。</p><p>Step 1： 构造初始堆</p><p>初始化堆时是对所有的非叶子结点进行筛选<br>最后一个非终端元素的下标是[n&#x2F;2]向下取整，所以筛选只需要从第[n&#x2F;2]向下取整个元素开始，从后往前进行调整。</p><p>Step 2：进行堆排序</p><p>堆排序是一种选择排序。建立的初始堆为初始的无序区。</p><p>排序开始，首先输出堆顶元素（因为它是最值），将堆顶元素和最后一个元素交换，这样，第n个位置（即最后一个位置）作为有序区，前n-1个位置仍是无序区，对无序区进行调整，得到堆之后，再交换堆顶和最后一个元素，这样有序区长度变为2。。。</p><p>不断进行此操作，将剩下的元素重新调整为堆，然后输出堆顶元素到有序区。每次交换都导致无序区-1，有序区+1。不断重复此过程直到有序区长度增长为n-1，排序完成。</p><h2 id="算法分析：-6"><a href="#算法分析：-6" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>因为建堆的时间复杂度是 O ( n ) O(n)O(n) ，调整堆的时间复杂度是 O ( l o g n ) O(logn)O(logn) ，所以堆排序的时间复杂度是 O ( n l o g n ) O(nlogn)O(nlogn)</li><li>由于在堆积排序中只需要一个记录大小的辅助空间，因此，堆积排序的空间复杂度为：O(1)。</li><li>堆排序属于 <strong>不稳定排序算法</strong>。堆排序也是一种不适合在链表上实现的排序。</li><li>堆排序方法<strong>对记录数较少的文件并不值得提倡</strong>，但对n较大的文件还是很有效的。因为其运行时间主要耗费在建初始堆和调整建新堆时进行的反复“筛选”上。</li></ul><h2 id="代码实现：-6"><a href="#代码实现：-6" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="案例实现：-6"><a href="#案例实现：-6" class="headerlink" title="案例实现："></a>案例实现：</h2><h1 id="八、计数排序"><a href="#八、计数排序" class="headerlink" title="八、计数排序"></a>八、计数排序</h1><h2 id="算法思想：-7"><a href="#算法思想：-7" class="headerlink" title="算法思想："></a>算法思想：</h2><p>使用一个额外的数组 <code>counts</code>，其中第 <code>i</code> 个元素 <code>counts[i]</code> 是待排序数组 <code>arr</code> 中值等于 <code>i</code> 的元素个数。然后根据数组 <code>counts</code> 来将 <code>arr</code> 中的元素排到正确的位置。</p><p>计数排序(Counting Sort)是<strong>一种不比较数据大小的排序算法</strong>，是一种牺牲空间换取时间的排序算法。</p><p>计数排序适合数据量大且数据范围小的数据排序，如对人的年龄进行排序，对考试成绩进行排序等。</p><h2 id="算法步骤：-7"><a href="#算法步骤：-7" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>找到待排序列表中的最大值 k，开辟一个长度为 k+1 的计数列表，计数列表中的值都为 0。</li><li>走访待排序列表，如果走访到的元素值为 i，则计数列表中索引 i 的值加1。</li><li>走访完整个待排序列表，计数列表中索引 i 的值 j 表示 i 的个数为 j，统计出待排序列表中每个值的数量。</li><li>创建一个新列表，遍历计数列表，依次在新列表中添加 j 个 i，新列表就是排好序后的列表，整个过程没有比较待排序列表中的数据大小。</li></ul><h2 id="算法分析：-7"><a href="#算法分析：-7" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>当输入元素是 <code>n</code> 个 <code>0 ~ k</code> 之间的整数时，计数排序的时间复杂度为 O(n+k)。</li><li>由于用于计数的数组 <code>counts</code> 的长度取决于待排序数组中数据的范围（等于待排序数组最大值减去最小值再加 <code>1</code>）。所以计数排序对于数据范围很大的数组，需要大量的时间和内存。</li><li>计数排序一般用于排序整数，不适用于按字母顺序排序人名。</li><li>计数排序是 <strong>稳定排序算法</strong>。</li></ul><h2 id="代码实现：-7"><a href="#代码实现：-7" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        arr_min<span class="token punctuation">,</span> arr_max <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        size <span class="token operator">=</span> arr_max <span class="token operator">-</span> arr_min <span class="token operator">+</span> <span class="token number">1</span>        counts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">]</span>   <span class="token comment">#生成一个全是0的列表，用于计数</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> arr<span class="token punctuation">:</span>            counts<span class="token punctuation">[</span>num <span class="token operator">-</span> arr_min<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">:</span>            counts<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> counts<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>   <span class="token comment">#新建一个列表用于存放新排序后的元素</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            res<span class="token punctuation">[</span>counts<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arr_min<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            counts<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> arr_min<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>countingSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-7"><a href="#案例实现：-7" class="headerlink" title="案例实现："></a>案例实现：</h2><p>【LeetCode】<a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></p><p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，<code>arr2</code> 中的元素各不相同，<code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中。</p><p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p><p>示例：</p><blockquote><pre class="line-numbers language-none"><code class="language-none">输入：arr1 &#x3D; [2,3,1,3,2,4,6,7,9,2,19], arr2 &#x3D; [2,1,4,3,9,6]输出：[2,2,2,1,4,3,3,9,6,7,19]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h1 id="九、桶排序"><a href="#九、桶排序" class="headerlink" title="九、桶排序"></a>九、桶排序</h1><h2 id="算法思想：-8"><a href="#算法思想：-8" class="headerlink" title="算法思想："></a>算法思想：</h2><p>将未排序的数组分到若干个「桶」中，每个桶的元素再进行单独排序。</p><h2 id="算法步骤：-8"><a href="#算法步骤：-8" class="headerlink" title="算法步骤："></a>算法步骤：</h2><ul><li>将区间划分为 <code>n</code> 个相同大小的子区间，每个区间称为一个桶。</li><li>遍历数组，将每个元素装入对应的桶中。</li><li>对每个桶内的元素单独排序（使用插入、归并、快排等算法）。</li><li>最后按照顺序将桶内的元素合并起来。</li></ul><h2 id="算法分析：-8"><a href="#算法分析：-8" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>桶排序可以在线性时间内完成排序，当输入元素个数为 <code>n</code>，桶的个数是 <code>m</code> 时，每个桶里的数据就是 <code>k = n / m</code> 个。每个桶内排序的时间复杂度为 O(k∗log2k)。<code>m</code> 个桶就是 $m * O(k * log_2k) &#x3D; m * O((n&#x2F;m)<em>log_2(n&#x2F;m)) &#x3D; O(n</em>log_2(n&#x2F;m))$。当桶的个数 <code>m</code> 接近于数据个数 <code>n</code> 时，log2(n&#x2F;m) 就是一个较小的常数，所以排序桶排序时间复杂度接近于 O(n)。</li><li>由于桶排序使用了辅助空间，所以桶排序的空间复杂度是 o(n+m)。</li><li>如果桶内使用插入排序算法等稳定排序算法，则桶排序也是 <strong>稳定排序算法</strong>。</li></ul><h2 id="代码实现：-8"><a href="#代码实现：-8" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            j <span class="token operator">=</span> i            <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token keyword">and</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                j <span class="token operator">-=</span> <span class="token number">1</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp        <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">,</span> bucket_size<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        arr_min<span class="token punctuation">,</span> arr_max <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token comment">#找到最大最小的数</span>        bucket_count <span class="token operator">=</span> <span class="token punctuation">(</span>arr_max <span class="token operator">-</span> arr_min<span class="token punctuation">)</span> <span class="token operator">//</span> bucket_size <span class="token operator">+</span> <span class="token number">1</span>  <span class="token comment">#划分子区间</span>        buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>bucket_count<span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment">#创建桶</span>        <span class="token keyword">for</span> num <span class="token keyword">in</span> arr<span class="token punctuation">:</span>            buckets<span class="token punctuation">[</span><span class="token punctuation">(</span>num <span class="token operator">-</span> arr_min<span class="token punctuation">)</span> <span class="token operator">//</span> bucket_size<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>   <span class="token comment">#将元素放置相对应的桶中</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>           <span class="token keyword">for</span> bucket <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>             self<span class="token punctuation">.</span>insertionSort<span class="token punctuation">(</span>bucket<span class="token punctuation">)</span>  <span class="token comment">#使用选择排序对桶中元素进行排序</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>bucket<span class="token punctuation">)</span>        <span class="token keyword">return</span> res    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>bucketSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-8"><a href="#案例实现：-8" class="headerlink" title="案例实现："></a>案例实现：</h2><h1 id="十、基数排序"><a href="#十、基数排序" class="headerlink" title="十、基数排序"></a>十、基数排序</h1><h2 id="算法思想：-9"><a href="#算法思想：-9" class="headerlink" title="算法思想："></a>算法思想：</h2><p><strong>将整数按位数切割成不同的数字</strong>，然后按每个位数分别比较进行排序。</p><h2 id="算法步骤：-9"><a href="#算法步骤：-9" class="headerlink" title="算法步骤："></a>算法步骤：</h2><p>基数排序算法可以采用「最低位优先法（Least Significant Digit First）」或者「最高位优先法（Most Significant Digit first）」。<strong>最常用的是「最低位优先法」</strong>。</p><p>下面我们以最低位优先法为例，讲解一下算法步骤。</p><ul><li>遍历数组元素，获取数组最大值元素，并取得位数。</li><li>以个位元素为索引，对数组元素排序。</li><li>合并数组。</li><li>之后依次以十位，百位，…，直到最大值元素的最高位处值为索引，进行排序，并合并数组，最终完成排序。</li></ul><h2 id="算法分析：-9"><a href="#算法分析：-9" class="headerlink" title="算法分析："></a>算法分析：</h2><ul><li>基数排序的时间复杂度是 O(k∗n)。其中 <code>n</code> 是待排序元素的个数，<code>k</code> 是数字位数。<code>k</code> 的大小取决于数字位的选择（十进制位、二进制位）和待排序元素所属数据类型全集的大小。</li><li>基数排序的空间复杂度是 O(n+k)。</li><li>基数排序是 <strong>稳定排序算法</strong>。</li></ul><h2 id="代码实现：-9"><a href="#代码实现：-9" class="headerlink" title="代码实现："></a>代码实现：</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>        size <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">#获取最大元素的位数</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">:</span>            buckets <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> num <span class="token keyword">in</span> arr<span class="token punctuation">:</span>                buckets<span class="token punctuation">[</span>num <span class="token operator">//</span> <span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">**</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>  <span class="token comment">#从个位开始进行排序</span>            arr<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">for</span> bucket <span class="token keyword">in</span> buckets<span class="token punctuation">:</span>                <span class="token keyword">for</span> num <span class="token keyword">in</span> bucket<span class="token punctuation">:</span>                    arr<span class="token punctuation">.</span>append<span class="token punctuation">(</span>num<span class="token punctuation">)</span>        <span class="token keyword">return</span> arr    <span class="token keyword">def</span> <span class="token function">sortArray</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>radixSort<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="案例实现：-9"><a href="#案例实现：-9" class="headerlink" title="案例实现："></a>案例实现：</h2>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【剑指offer】第一天：栈与队列</title>
      <link href="/2022/02/09/jian-zhi-offer-di-yi-tian-zhan-yu-dui-lie/"/>
      <url>/2022/02/09/jian-zhi-offer-di-yi-tian-zhan-yu-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>示例：</p><blockquote><p>输入：<br>[“CQueue”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[3],[],[]]<br>输出：[null,null,3,-1]</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。</p><p>根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CQueue</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment">#新建两个栈</span>        self<span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">appendTail</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>value<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>        <span class="token comment">#如果stack2中没有元素，则先将stack1中元素新增进去后在进行pop()</span>        <span class="token keyword">while</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p><p>示例：</p><blockquote><p>MinStack minStack &#x3D; new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.min();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.min();   –&gt; 返回 -2.</p></blockquote><h1 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h1><p>根据题意，我们需要在常量级的时间内找到最小值！<br>这说明，我们绝不能在需要最小值的时候，再做排序，查找等操作来获取！<br>所以，我们可以创建两个栈，一个栈是主栈 stackstack，另一个是辅助栈 minStackminStack，用于存放对应主栈不同时期的最小值。</p><h1 id="二、题解"><a href="#二、题解" class="headerlink" title="二、题解"></a>二、题解</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">MinStack</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""        initialize your data structure here.        """</span>        <span class="token comment">#新建两个栈</span>        self<span class="token punctuation">.</span>stack1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        self<span class="token punctuation">.</span>stack2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>   <span class="token keyword">def</span> <span class="token function">push</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">:</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token comment">#将元素填入栈1中，并进行判断，如果栈2无元素或者栈2最上边的元素大于等于x，则将x元素填入栈2中</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>stack2 <span class="token keyword">or</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>=</span> x<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">pop</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token boolean">None</span><span class="token punctuation">:</span>    <span class="token comment">#如果抛出的元素和栈2的最后一个元素相等也一起抛出，保持两栈的一致性</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stack2<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">top</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack1<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">min</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>    <span class="token comment">#直接返回栈2的最后一个元素便是最小值</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>stack2<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>栈是一个“先进后出”的线性结构，队列是一个“先进先出”的线性结构。<br>很多时候可以使用这两个特殊的特性进行解题，力扣中也有许多可以利用栈和队列的数据结构进行解题的题目</p>]]></content>
      
      
      <categories>
          
          <category> 【LeetCode】 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo和github搭建个人博客网站详细流程</title>
      <link href="/2022/02/06/shi-yong-hexo-he-github-da-jian-ge-ren-bo-ke-wang-zhan-xiang-xi-liu-cheng/"/>
      <url>/2022/02/06/shi-yong-hexo-he-github-da-jian-ge-ren-bo-ke-wang-zhan-xiang-xi-liu-cheng/</url>
      
        <content type="html"><![CDATA[<blockquote><p>机缘巧合了解到了个人博客这个东西，之前试过一次，但是因为某些原因，让我放弃了，感觉太难了，但是这次下定决心，花了很长的时间终于是搞定了，虽然找到了很详细的教程，但是也遇到了很多的问题，主要还是要细心，同时出现了问题其实都可以搜索到解决方法，下边将自己的搭建过程做一个记录。<br>先附上大佬教程：<a href="https://huahuipj.github.io/2021/08/20/shi-yong-github-bu-shu-yi-ge-jian-dan-de-bo-ke/">https://huahuipj.github.io/2021/08/20/shi-yong-github-bu-shu-yi-ge-jian-dan-de-bo-ke/</a></p></blockquote><h1 id="一、-搭建github仓库"><a href="#一、-搭建github仓库" class="headerlink" title="一、 搭建github仓库"></a>一、 搭建github仓库</h1><h2 id="1-注册账号"><a href="#1-注册账号" class="headerlink" title="1.注册账号"></a>1.注册账号</h2><p>大家介绍搭建的博客是部署在Github上的，所以肯定是要有一个Github账号的，没有的小伙伴去注册一个吧，操作比较简单这里就不在多讲了。</p><h2 id="2-创建仓库"><a href="#2-创建仓库" class="headerlink" title="2.创建仓库"></a>2.创建仓库</h2><p>进入github中后点击右上角“+”号，点击“New repository” ：<br><img src="https://img-blog.csdnimg.cn/f6d145cde5ca4d0a942d0c37ff2c5620.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="新建github仓库"></p><p>命名一定要和用户名一致，类似：super0514.github.io</p><h2 id="3-出现问题"><a href="#3-出现问题" class="headerlink" title="3.出现问题"></a>3.出现问题</h2><p>其一、登陆github网速问题：<br>因为github毕竟是国外的网站，所以我们访问的时候会很慢，并且很难进去，这里推荐给大家一个大佬gitee的加速器：<a href="https://gitee.com/docmirror/dev-sidecar?_from=gitee_search">https://gitee.com/docmirror/dev-sidecar?_from=gitee_search</a></p><blockquote><p>需要注意的是未关闭下不要重启电脑，不然会导致无法上网，可以设置自启动</p></blockquote><p>其二、创建github令牌：<br>因为我们在使用git提交信息时，现在不在使用密码，而是使用令牌token了，所以我们需要创建一个新的令牌，这里我就偷个懒，毕竟这里没出啥问题，把大佬的链接奉上：<a href="https://docs.github.com/cn/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">如何创建个人访问令牌</a></p><blockquote><p>需要注意的是创建好后需要保存好令牌，第二次打开后是看不到令牌了的</p></blockquote><h1 id="二、将博客部署至github中"><a href="#二、将博客部署至github中" class="headerlink" title="二、将博客部署至github中"></a>二、将博客部署至github中</h1><h2 id="1-下载相关“配件”"><a href="#1-下载相关“配件”" class="headerlink" title="1.下载相关“配件”"></a>1.下载相关“配件”</h2><p>安装git 这个是身为一个程序员必备的啦，相信大家都已经安装了，没有安装的话可以去网上搜索下安装流程，也比较简单。</p><p>安装node.js 和 hexo</p><p>这个也很简单，网上都能搜索到：<br>大佬们也都整理好了嘿嘿   <a href="https://blog.csdn.net/Small_Yogurt/article/details/104968169">node.js具体安装步骤</a><br>安装完node.js后就要安装hexo啦</p><p>首先在磁盘建立一个文件夹 Blog，点开Blog文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo<br><img src="https://img-blog.csdnimg.cn/62d019866bf04dcf9db317ffcdeb39d6.png" alt="安装hexo"><br>安装完成后，输入 hexo init命令初始化博客：<br><img src="https://img-blog.csdnimg.cn/d8c41b6dad314be980a783475fad0603.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="初始化hexo"><br>然后输入 hexo g 静态部署：<br><img src="https://img-blog.csdnimg.cn/c82e8ca17cdc48358feffa22ffaa7bf6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="部署hexo"><br>这时网页已经部署完成，输入 hexo s 命令可以查看：<br><img src="https://img-blog.csdnimg.cn/d350df29f3ee4728a490ac608889aa06.png"><br>浏览器输入 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以打开新部署的网页：<br>因为自己已经部署完成了，所以借助了一下其他地方的图片展示<br><img src="https://img-blog.csdnimg.cn/e4336d44ecf84b17bea523c31a5af4c0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>使用Ctrl+c 可以停止运行服务器</p><p>这样我们的基本“配件”都搞定了，接下来我们将hexo博客部署至github上</p><h2 id="2-将hexo部署到github上"><a href="#2-将hexo部署到github上" class="headerlink" title="2.将hexo部署到github上"></a>2.将hexo部署到github上</h2><p>现在回到我们的 Blog 文件夹，用笔记本打开 _config.yml 文件，如下图：<br><img src="https://img-blog.csdnimg.cn/a78e4d3a8cdb472bba2f2d5fc99f57a3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16"><br>打开后，下滑至文件底部，填上以下内容：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">deploy<span class="token punctuation">:</span>  <span class="token builtin">type</span><span class="token punctuation">:</span> git  repository<span class="token punctuation">:</span> https<span class="token punctuation">:</span><span class="token operator">//</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>super0514<span class="token operator">/</span>super0514<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git  <span class="token comment">#你的仓库地址</span>  branch<span class="token punctuation">:</span> main<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>branch 填你刚刚创建GitHub仓库的默认分支名称，看下是master还是main，不要填错了，还要注意一下，冒号后面加一个空格</p><blockquote><p>只要是配置文件中更改内容或者填写内容，冒号后边都需要加一个空格</p></blockquote><p>然后回到 Blog 文件夹中，打开Git Bash，安装Git部署插件，输入命令：<br>npm install hexo-deployer-git –save</p><p>然后分别输入三条命令（“三部曲”）：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">hexo clean   <span class="token comment">#清除缓存文件 db.json 和已生成的静态文件 public</span>hexo g       <span class="token comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span>hexo d       <span class="token comment">#自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>完成以后，打开浏览器，输入 <a href="https://xxx.github.io就可以打开你的网页了/">https://xxx.github.io就可以打开你的网页了</a>, 比如我的博客地址为<a href="https://super0514.github.io,如果你的博客没有显示或刷新可以等一小会儿再刷新一下,它可能会有延迟的问题.到这一步为止,你已经成功部署了属于你自己的一个简单博客了,不过样式看起来不怎么好看,接下来我们使用主题hexo-theme-matery来美化一下我们的博客./">https://super0514.github.io，如果你的博客没有显示或刷新可以等一小会儿再刷新一下，它可能会有延迟的问题。到这一步为止，你已经成功部署了属于你自己的一个简单博客了，不过样式看起来不怎么好看，接下来我们使用主题hexo-theme-matery来美化一下我们的博客。</a></p><h2 id="3-出现问题-1"><a href="#3-出现问题-1" class="headerlink" title="3.出现问题"></a>3.出现问题</h2><p>其一、hexo g 命令问题：<br>我们在使用hexo g 命令生成网站静态文件时，可能会出现文件不能被创建的问题，导致失败，这里我们需要注意两个点，一个是插件是否没问题 输入：npm ls –depth 0<br>可以查看查看，如果没有则不是这个问题，还有一个就是我们使用的主题文件名要和写入配置文件中的一致，否则也会出错。<br><img src="https://img-blog.csdnimg.cn/548cfa51750a4b1898b45d88f59f7961.png" alt="配置文件信息"><br>其二、hexo d命令问题：<br>我们使用hexo d命令是将文件部署至仓库中，但是由于网络的问题时常会出现下图情况，没关系，ctrl+c 退出，重新执行一次命令试试<br><img src="https://img-blog.csdnimg.cn/4896b537f0914d1ca377d93c217acf1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="hexo d部署问题"></p><blockquote><p>同时部署时也需要登陆github，这里就上最开始说的，部署时，需要使用令牌，不是github的密码哦</p></blockquote><h1 id="三、使用matery主题美化博客"><a href="#三、使用matery主题美化博客" class="headerlink" title="三、使用matery主题美化博客"></a>三、使用matery主题美化博客</h1><blockquote><p>最开始的时候并不知道，原来有好多主题，当然matery也是很不错的一种，这里我们就跟着大佬的教程，使用matery主题来进行美化博客吧</p></blockquote><p>别的不说，先把大佬教程奉上，很全面：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE-tags-%E9%A1%B5">matery主题详细配置</a><br>虽然我通过这个教程完成了，但是刚开始好多没看明白，后边终于搞懂了，害<br>接下来在奉上自己的配置流程<br><img src="https://img-blog.csdnimg.cn/2eaeea5845e5435a9b4d490bff11f9ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="下载主题"><br>刚开始自己在这就吃亏了，这个主题是放在blog文件夹里的themes文件夹，不是再里边的hexo里的themes文件夹，这里提个醒</p><blockquote><p>教程里所指的hexo根目录都是我们创建的blog目录下</p></blockquote><p>然后在跟着教程创建tags等页面：<br><img src="https://img-blog.csdnimg.cn/b893626b4d6749c4809c83aac84b1d00.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="matery主题配置"><br>当然类似一些聊天、评论的配置就没有进行详细的配置了，下一篇在进行深入美化哦，这里只做基础配置</p><blockquote><p>基础配置都没什么大问题，只要注意文件的位置和配置信息不出错</p></blockquote><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><p>补充一下如何发布文章，我自己在用的就是csdn，里边有这个Markdown编辑器，写完文章后可以导出，然后保存在blog文件夹source文件夹中的_posts文件夹中，然后在用记事本打开文件<br><img src="https://img-blog.csdnimg.cn/c38152dc5c864a1890e213f573efa313.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>title ： 标题<br>categories ： 分类<br>tags ： 标签<br>将文件进行修改后在使用hexo“三部曲”中的hexo g 生成文件，使用hexo d 将文件部署至仓库<br>然后访问网站便可以看到啦<br><img src="https://img-blog.csdnimg.cn/5a88ac26622d4a9a84ea4b0c169c854c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_17,color_FFFFFF,t_70,g_se,x_16" alt="发布文章"><br>这样就可以啦！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一个简单的个人博客就完成啦，大家都可以试着去操作一下，虽然这只是最基础的步骤，但是后续还会继续完善自己的小站哒，大家有空可以来关顾下我的网站哦：<a href="https://super0514.github.io/">没事请叫我去学习</a><br>未完待续，下次再见啦！</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器免费获取体验--【开发者成长计划】</title>
      <link href="/2022/02/06/a-li-yun-fu-wu-qi-mian-fei-huo-qu-ti-yan-kai-fa-zhe-cheng-chang-ji-hua/"/>
      <url>/2022/02/06/a-li-yun-fu-wu-qi-mian-fei-huo-qu-ti-yan-kai-fa-zhe-cheng-chang-ji-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了完成学校老师布置的任务，需要能够让项目组其他队友共享本地数据库，后边想到了服务器，将数据库部署到服务器中便可以了，然后在网上搜索相关内容，发现有一个阿里云的免费体验计划，立马就去弄了，顺便记录一下。</p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="一、使用前提"><a href="#一、使用前提" class="headerlink" title="一、使用前提"></a>一、使用前提</h1><ul><li>每一位用户只能领取一次，需要进行实名验证</li><li>专门为高校学生准备的福利，需要进行学生认证</li></ul><h1 id="二、获取步骤"><a href="#二、获取步骤" class="headerlink" title="二、获取步骤"></a>二、获取步骤</h1><h2 id="1-进行初次领取"><a href="#1-进行初次领取" class="headerlink" title="1.进行初次领取"></a>1.进行初次领取</h2><p>活动网址：<a href="https://developer.aliyun.com/plan/grow-up">https://developer.aliyun.com/plan/grow-up</a></p><p>进入网址后先要进行用户注册，记住一定是要新用户哦。<br><img src="https://img-blog.csdnimg.cn/b789c4d3dce24c53b97b740a87de1d0b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>进行实名认证后便可以进行领取，完成相对应的步骤。<br><img src="https://img-blog.csdnimg.cn/f12b4b3ad08b462d9b1724d45812f10d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>点击进行领取，初次领取是15天，8月多以前是有6个月领取时间的，但是现在最长领取时间是2个半月，初次领取15天，随后续领2个月。</p><p>点击免费领取，然后完成相对应的任务，便可以领取</p><p><img src="https://img-blog.csdnimg.cn/5c164ed173c44e2cb825d66651a03057.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>注册登录完成后，进行学生认证，这个很简单，高校学生直接填写好后就可以啦</p><p>接下去就是新手预备营任务，能够让大家提前了解和体验一下领取服务器后如何进行初步管理，提供模拟教程进行学习，当然如果不是小白，直接开启资源后进行跳过就可以（小声bb），建议还是通过一下比较好，新人能够学习一下，老人能够回顾一下流程。</p><p><img src="https://img-blog.csdnimg.cn/32105efc9d7a4c97b9207994a074b4b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>这是预备营的任务，第一个模拟教程完成后，便可以进行考试，考试的话一般难度不高，不懂的也可以在网上进行搜索。</p><p>成功后便可以进行免费领取，然后可以自行选择使用哪种操作系统</p><blockquote><p>注意每次的每次的领取时间是从早上8点开始的哦，如果晚上去领取的很有可能当天的被领取完了哦</p></blockquote><p>所以早起的鸟儿有草吃hhhhhh</p><h2 id="2-免费续领"><a href="#2-免费续领" class="headerlink" title="2.免费续领"></a>2.免费续领</h2><p>15天很快就过去了，领取完后，我们可以再次进行续领，但是续领也是有要求的<br><img src="https://img-blog.csdnimg.cn/ddee88d382774e5185d154f91b5b2a89.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA57uI6Lqr5a2m5LmgKg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>需要我们写一篇使用服务器的体会文章，然后提交在阿里云社区，文章的话建议有一些使用过程中的图片，这样可以提供通过率，如果不符合要求的还会被退下来哦</p><p>第二个就是发布一篇文章，尽量是原创，这样的通过率也高。</p><blockquote><p>对于续领，一定要记住，提前发布文章，审核文章需要好久，建议初次领取后，进行服务器使用了，就开始写文章，越早写了越好，防止审核还没通过，使用期就已经过了。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总共2个半月的免费体验时间，大家可以多多使用服务器，帮助自己学习一些其他的东西和知识，如果后期需要购买其实也很实惠，因为新用户都是有优惠的。<br>能够达到100多元购买3年期限，不过这也是功能比较少的，主要还是看需求，如果只是自己建建网站的话，最普通的就可以了。如果需要其他的，大家可以按照自己需求来，新用户优惠都很大的。</p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云服务器 </tag>
            
            <tag> 免费 </tag>
            
            <tag> 小白教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/04/hello-world/"/>
      <url>/2022/02/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
